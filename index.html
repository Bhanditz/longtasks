<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Long Tasks Observer</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
      // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
      var respecConfig = {
        specStatus: "CG-DRAFT",
        shortName: "longtasks",
        editors: [{
          name: "Shubhie Panicker",
          mailto: "panicker@chromium.org",
          company: "Google Inc.",
          companyURL: "https://google.com/",
          w3cid: "xyz"
        }, {
          name: "Add 2nd author here",
          mailto: "author@chromium.org",
          company: "Google Inc.",
          companyURL: "https://google.com/",
          w3cid: "xyz"
        }, {
          name: "Add 3rd author here",
          mailto: "author@chromium.org",
          company: "Google Inc.",
          companyURL: "https://google.com/",
          w3cid: "xyz"
        }],
        wg: "Web Performance Working Group",
        wgURI: "http://www.w3.org/webperf/",
        license: 'w3c-software-doc',
        wgPublicList: "public-web-perf",
        subjectPrefix: "[LongTasks]",
        format: "markdown",
        otherLinks: [{
          key: 'Repository',
          data: [{
            value: 'We are on Github.',
            href: 'https://github.com/wicg/longtasks'
          }, {
          value: 'File a bug.',
          href: 'https://github.com/WICG/longtasks/issues'
      }, {
        value: 'Commit history.',
        href: 'addme.html'
      }, {
        value: 'Tests.',
        href: 'addme'
      }]
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document defines an API that web page authors can use to detect presence of “long tasks” that monopolize the UI thread for extended periods of time and block other critical tasks from being executed - e.g. reacting to user input.

      </p>
    </section>
    <section id="sotd">
      <p>This is a <strong>work in progress</strong> and may change without any
        notices.</p>
      <p id="unstable"><strong class="redNote">Implementers SHOULD be aware that this document is not stable.</strong> Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this document before it eventually reaches the Candidate Recommendation stage SHOULD join the mailing lists below and take part in the discussions.</p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        As the page is loading and while the user is interacting with the page afterwards, both the application and browser, queue various events that are then executed by the browser -- e.g. user agent schedules input events based on user’s activity, the application schedules callbacks for requestAnimationFrame and other callbacks etc. Once in the queue, these events are then dequeued one-by-one by the browser and executed — e.g. see <a href="">“the anatomy of a frame”</a> for a high-level overview of this process in Blink.</p>
      <p>
        However, some task can take a long time (multiple frames), and if and when that happens, the UI thread is locked and all other tasks are blocked as well. To the user this is commonly visible as a “locked up” page where the browser is unable to respond to user input; this is a major source of bad user experience on the web today:
        <ul>
          <li><strong>Delayed “time to Interactive”</strong>: while the page is loading long tasks often tie up the main thread and prevent the user from interactive with the page even though the page is visually rendered. Poorly designed third-party content is a frequent culprit.</li>
          <li><strong>High/variable input latency</strong>: critical user interaction events (tap, click, scroll, wheel, etc) are queued behind long tasks, which yields janky and unpredictable user experience.</li>
          <li><strong>High/variable event handling latency</strong>: similar to input, but for processing event callbacks (e.g. onload events, and so on), which delay application updates.</li>
          <li><strong>Janky animations and scrolling</strong>: some animation and scrolling interactions require coordination between compositor and main threads; if the main thread is blocked due to a long task, it can affect responsiveness of animations and scrolling.</li>
        </ul>
      </p>
      <p>
        Some applications (and RUM vendors) are already attempting to identify and track cases where “long tasks” happen. For example, one known pattern is to install a ~short periodic timer and inspect the elapsed time between the successive calls: if the elapsed time is greater than the timer period, then there is high likelihood that one or more long tasks have delayed execution of the timer. This mostly works, but it has several bad performance implications: the application is polling to detect long tasks, which prevents quiescence and long idle blocks (see requestIdleCallback); it’s bad for battery life; there is no way to know who caused the delay (e.g. first party vs third party code)
      </p>
      <p>
        RAIL performance model suggests that applications should respond in under 100ms to user input; for touch move and scrolling in under 16ms. Our goal with this API is to surface notifications about tasks that may prevent the application from hitting these targets.
      </p>

      <p>Example of using the API to capture long tasks.</p>
      <pre class='example highlight'>
      var observer = new PerformanceObserver(function(list) {
        var perfEntries = list.getEntries();
        for (var i = 0; i < perfEntries.length; i++) {
          // Process long task notifications:
          // report back for analytics and monitoring
          // ...
        }
      });

      // register observer for long task notifications
      observer.observe({entryTypes: ["longtask"]});

      // Long script execution after this will result in queueing 
      // and receiving “longtask” entries in the observer.
      </pre>
    </section>
  
    <section id="sec-longtask-timing">
    <h2>Long Task Timing</h2>
    <section id='performanceentry'>
     </section>

   <section id="sec-PerformanceLongTaskTiming">
      <h3>The <code>PerformanceLongTaskTiming</code> interface:</h3>
      <pre class="def idl">
       interface PerformanceTaskTiming : PerformanceEntry {
        readonly attribute sequence<<code>TaskAttributionTiming</code>> attribution;
       };
      </pre>

      <p>PerformanceLongTaskTiming extends the following attributes of <a href="http://www.w3.org/TR/performance-timeline-2/#idl-def-PerformanceEntry">PerformanceEntry</a> interface:</p>
      <ul>
      <li>The <dfn id='dom-PerformanceLongTaskTiming-name'><code>name</code></dfn> attribute must return <code>DOMString</code> for minimal frame attribution. Possible values of name are:
        <ul>
          <li><code>same-origin-self</code>: long task is from within my own frame context</li>
          <li><code>same-origin-ancestor</code>: long task is from a same-origin ancestor context</li>
          <li><code>same-origin-descendant</code>: long task is from a same-origin descendant context</li>
          <li><code>same-origin</code>: long task is from an unreachable same-origin context</li>
          <li><code>cross-origin-ancestor</code>: long task is from a cross-origin ancestor context</li>
          <li><code>cross-origin-descendant</code>: long task is from a cross-origin descendant context</li>
          <li><code>cross-origin-unreachable</code>: long task is from a cross-origin unreachable context</li>
          <li><code>multiple-contexts</code>: multiple frame contexts were involved in the long task</li>
          <li><code>unknown</code>: none of the above</li>
        </ul>
 
      <li>The <code>entryType</code> attribute must return <code>"longtask"</code></li>
      <li>The <code>startTime</code> attribute MUST return a <a href="http://www.w3.org/TR/hr-time/#dom-domhighrestimestamp">DOMHighResTimeStamp</a> of when the task started.</li>
      <li>The <code>duration</code> attribute MUST return a <a href="http://www.w3.org/TR/hr-time/#dom-domhighrestimestamp">DOMHighResTimeStamp</a> equal to the elapsed time between the start and end of task</li>
      <!--li>The <dfn id='dom-PerformanceLongTaskTiming-attribution'><code>attribution</code></dfn> attribute MUST return a sequence of<a href="TODO">TaskAttributionTiming</a> 
       entries, a new PerformanceEntry type to report attribution within long tasks.</li-->
      </ul>

      <p>PerformanceLongTaskTiming adds the following attributes:
      <ul>
      <li> The <code>attribution</code> field returns a sequence of <code>TaskAttributionTiming<</code> entries.</li>
      </ul>
      <p>

      <section id="sec-TaskAttributionTiming">
        <h3>The <code>TaskAttributionTiming</code> interface:</h3>
        <pre class="def idl">
          interface TaskAttributionTiming : PerformanceEntry {
            readonly attribute DOMString frameSrc;
            readonly attribute DOMString frameId;
            readonly attribute DOMString frameName;
         };
        </pre>
        <p>
        TaskAttributionTiming extends the following attributes of PerformanceEntry interface:
        <ul>
          <li>The <code>name</code> attribute must return <code>DOMString</code> indicating type of attribution. Currently this can <code>"frame"</code>.</li>
          <li>The <code>entryType</code> attribute must return <code>DOMString</code> <code>"taskattribution"</code></li>
          <li>The <code>startTime</code> attribute MUST return 0.</li>
          <li>The <code>duration</code> attribute MUST return 0.</li>
        </ul>
        </p>
        <p>TaskAttributionTiming adds the following attributes:
        <ul>
          <li>The <code>frame-name</code> attribute must return <code>DOMString</code> with culprit iframe's <code>name</code> attribute.</li>
          <li>The <code>frame-id</code> attribute must return <code>DOMString</code> with culprit iframe's <code>id</code> attribute.</li>
          <li>The <code>frame-src</code> attribute must return <code>DOMString</code> with culprit iframe's <code>src</code> attribute.</li>
        </ul>
        </p>
      </section>
  </body>
</html>
