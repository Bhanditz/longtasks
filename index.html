<!doctype html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Long Tasks API</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
        // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
        var respecConfig = {
          specStatus: "CG-DRAFT",
          shortName: "longtasks",
          editors: [{
            name: "Shubhie Panicker",
            mailto: "panicker@chromium.org",
            company: "Google Inc.",
            companyURL: "https://google.com/",
            w3cid: "xyz"
          }, {
            name: "Ilya Grigorik",
            mailto: "igrigorik@chromium.org",
            company: "Google Inc.",
            companyURL: "https://google.com/",
            w3cid: "xyz"
          }, {
            name: "Domenic Denicola",
            mailto: "domenic@chromium.org",
            company: "Google Inc.",
            companyURL: "https://google.com/",
            w3cid: "xyz"
          }],
          wg: "Web Performance Working Group",
          wgURI: "http://www.w3.org/webperf/",
          license: 'w3c-software-doc',
          wgPublicList: "public-web-perf",
          subjectPrefix: "[LongTasks]",
          format: "markdown",
          otherLinks: [{
            key: 'Repository',
            data: [{
              value: 'We are on Github.',
              href: 'https://github.com/wicg/longtasks'
            }, {
              value: 'File a bug.',
              href: 'https://github.com/WICG/longtasks/issues'
            }, {
              value: 'Commit history.',
              href: 'addme.html'
            }, {
              value: 'Tests.',
              href: 'addme'
            }],
          }]
        };
      </script>
    </head>
    <body>
      <section id="abstract">
        <p>
          This document defines an API that web page authors can use to detect presence of “long tasks” that monopolize the UI thread for extended periods of time and block other critical tasks from being executed - e.g. reacting to user input.
        </p>
      </section>
      <section id="sotd">
        <p>This is a <strong>work in progress</strong> and may change without any
          notices.</p>
          <p id="unstable"><strong class="redNote">Implementers SHOULD be aware that this document is not stable.</strong> Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this document before it eventually reaches the Candidate Recommendation stage SHOULD join the mailing lists below and take part in the discussions.</p>
        </section>
        <section id="introduction">
          <h2>Introduction</h2>
          <p>
            As the page is loading and while the user is interacting with the page afterwards, both the application and browser, queue various events that are then executed by the browser -- e.g. user agent schedules input events based on user’s activity, the application schedules callbacks for requestAnimationFrame and other callbacks etc. Once in the queue, these events are then dequeued one-by-one by the browser and executed.</p>
            <p>
              However, some task can take a long time (multiple frames), and if and when that happens, the UI thread is locked and all other tasks are blocked as well. To the user this is commonly visible as a “locked up” page where the browser is unable to respond to user input; this is a major source of bad user experience on the web today:
              <ul>
                <li><strong>Delayed “time to Interactive”</strong>: while the page is loading long tasks often tie up the main thread and prevent the user from interactive with the page even though the page is visually rendered. Poorly designed third-party content is a frequent culprit.</li>
                <li><strong>High/variable input latency</strong>: critical user interaction events (tap, click, scroll, wheel, etc) are queued behind long tasks, which yields janky and unpredictable user experience.</li>
                <li><strong>High/variable event handling latency</strong>: similar to input, but for processing event callbacks (e.g. onload events, and so on), which delay application updates.</li>
                <li><strong>Janky animations and scrolling</strong>: some animation and scrolling interactions require coordination between compositor and main threads; if the main thread is blocked due to a long task, it can affect responsiveness of animations and scrolling.</li>
              </ul>
            </p>
            <p>
              Some applications (and RUM vendors) are already attempting to identify and track cases where “long tasks” happen. For example, one known pattern is to install a ~short periodic timer and inspect the elapsed time between the successive calls: if the elapsed time is greater than the timer period, then there is high likelihood that one or more long tasks have delayed execution of the timer. This mostly works, but it has several bad performance implications: the application is polling to detect long tasks, which prevents quiescence and long idle blocks (see requestIdleCallback); it’s bad for battery life; there is no way to know who caused the delay (e.g. first party vs third party code)
            </p>
            <p>
              RAIL performance model suggests that applications should respond in under 100ms to user input; for touch move and scrolling in under 16ms. Our goal with this API is to surface notifications about tasks that may prevent the application from hitting these targets.
            </p>

            <section id="example">
              <h3>Usage Example</h3>
              <p>Example of using the API to capture long tasks.</p>
              <pre class="example highlight">
                var observer = new PerformanceObserver(function(list) {
                var perfEntries = list.getEntries();
                for (var i = 0; i < perfEntries.length; i++) {
                // Process long task notifications:
                // report back for analytics and monitoring
                // ...
              }
            });
            // register observer for long task notifications
            observer.observe({entryTypes: ["longtask"]});
            // Long script execution after this will result in queueing
            // and receiving “longtask” entries in the observer.
          </pre>
        </section>
      </section>

      <section id="sec-terminology">
        <h2>Terminology</h2>
        <p><dfn data-dfn-type="dfn" id="dfn-long-task">long task</dfn> refers to an event loop task that exceeds 50ms.
        </p>
        <p><dfn data-dfn-type="dfn" id="dfn-frame">frame</dfn> or <dfn data-dfn-type="dfn" id="dfn-frame-context">frame context</dfn> refers to the browsing context, such as iframe (not animation frame), embed or object in which some work (such as script or layout) occurs.
        </p>  
        <p><dfn data-dfn-type="dfn" id="dfn-culprit-frame">culprit frame</dfn> refers to the browsing context (iframe, embed or object etc) that is being implicated, on the whole, for a long task.
        </p>
        <p><dfn data-dfn-type="dfn" id="dfn-attribution">attribution</dfn> refers to identifying the type of work (such as script, layout etc.) that contributed significantly to the long task AND which browsing context is responsible for that work.
        </p>
      </section>


      <section id="sec-longtask-timing">
        <h2>Long Task Timing</h2>
        <p>Long Task timing involves the following new interfaces</p>
        <section id="sec-PerformanceLongTaskTiming" data-dfn-for="PerformanceLongTaskTiming" data-link-for="PerformanceLongTaskTiming" data-link-for="TaskAttributionTiming">
          <h3><dfn>PerformanceLongTaskTiming</dfn> interface</h3>
          <pre class="def idl">
           interface PerformanceLongTaskTiming : PerformanceEntry {
           readonly attribute FrozenArray&lt;TaskAttributionTiming&gt; attribution;
         };
       </pre>
       <p>PerformanceLongTaskTiming extends the following attributes of <a href="http://www.w3.org/TR/performance-timeline-2/#idl-def-PerformanceEntry">PerformanceEntry</a> interface:</p>
       <ul>
        <li>The <code>name</code> attribute must return <code>DOMString</code> for minimal frame attribution. Possible values of name are:
          <ul>
            <li><code>self</code>: long task is from within my own frame</li>
            <li><code>same-origin-ancestor</code>: long task is from a same-origin ancestor frame</li>
            <li><code>same-origin-descendant</code>: long task is from a same-origin descendant frame</li>
            <li><code>same-origin</code>: long task is from an unreachable same-origin frame</li>
            <li><code>cross-origin-ancestor</code>: long task is from a cross-origin ancestor frame</li>
            <li><code>cross-origin-descendant</code>: long task is from a cross-origin descendant frame</li>
            <li><code>cross-origin-unreachable</code>: long task is from a cross-origin unreachable frame</li>
            <li><code>multiple-contexts</code>: multiple frame contexts were involved in the long task</li>
            <li><code>unknown</code>: none of the above</li>
          </ul>
        </li>
        <li>The <code>entryType</code> attribute must return <code>"longtask"</code></li>
        <li>The <code>startTime</code> attribute MUST return a <a href="http://www.w3.org/TR/hr-time/#dom-domhighrestimestamp">DOMHighResTimeStamp</a> of when the task started.</li>
        <li>The <code>duration</code> attribute MUST return a <a href="http://www.w3.org/TR/hr-time/#dom-domhighrestimestamp">DOMHighResTimeStamp</a> equal to the elapsed time between the start and end of task</li>
      </ul>
      PerformanceLongTaskTiming adds the following attributes:
      <ul>
        <li> The <dfn>attribution</dfn> field returns a sequence of <a>TaskAttributionTiming</a> entries.</li>
      </ul>
    </section>
    <p></p>
    <section id="sec-TaskAttributionTiming" data-dfn-for="TaskAttributionTiming" data-link-for="TaskAttributionTiming">
      <h3><dfn>TaskAttributionTiming</dfn> interface</h3>
      <pre class="def idl">
        interface TaskAttributionTiming : PerformanceEntry {
        readonly attribute DOMString containerType;
        readonly attribute DOMString containerSrc;
        readonly attribute DOMString containerId;
        readonly attribute DOMString containerName;
      };
    </pre>

    <p>TaskAttributionTiming extends the following attributes of PerformanceEntry interface:</p>
    <ul>
      <li>The <code>name</code> attribute must return <code>DOMString</code> indicating type of attribution. Currently this can <code>"script"</code>.</li>
      <li>The <code>entryType</code> attribute must return <code>DOMString</code> <code>"taskattribution"</code></li>
      <li>The <code>startTime</code> attribute MUST return 0.</li>
      <li>The <code>duration</code> attribute MUST return 0.</li>
    </ul>

    <p>TaskAttributionTiming adds the following attributes:</p>
    <ul>
      <li>The <dfn>containerType</dfn> attribute must return <code>DOMString</code> with type of frame container, such as <code>"iframe"</code>, <code>"embed"</code>, <code>"object"</code>.</li>
      <li>The <dfn>containerName</dfn> attribute must return <code>DOMString</code> with container's <code>name</code> attribute.</li>
      <li>The <dfn>containerId</dfn> attribute must return <code>DOMString</code> with container's <code>id</code> attribute.</li>
      <li>The <dfn>containerSrc</dfn> attribute must return <code>DOMString</code> with container's <code>src</code> attribute.</li>
    </ul>
  </section>
  <p></p>
  <section id="sec-PointingToCulprit" data-link-for="PerformanceLongTaskTiming" data-link-for="TaskAttributionTiming">
    <h3>Pointing to the culprit</h3>
    <p>
      Long task represents the top level event loop task. Within this task, different types of work (such as script, layout, style etc) may be done, and they could be executed within different frame contexts. The type of work could also be global in nature such as a long GC that is process or frame-tree wide.</p>
      Thus pointing to the culprit has couple of facets:
      <ul>
        <li>Pointing to the overall frame to blame for the long task on the whole: this is refered to as "minimal frame attribution" and is captured in the <code>name</code> field</li>
        <li>Pointing to the type of work involved in the task, and its associated frame context: this is captured in <a>TaskAttributionTiming</a> objects in the <a>attribution</a> field of <a>PerformanceLongTaskTiming</a></li>
      </ul>
      <p>
        Therefore, <code>name</code> and <a>attribution</a> fields on <a>PerformanceLongTaskTiming</a> together paint the picture for where the blame rests for a long task.
        When delivering this information the web origin-policy must be adhered to.<br>
        As an illustration, the <a>TaskAttributionTiming</a> entry in <a>attribution</a> is populated with "script" work, and the container or frame implicated in attribution should match up with the <code>name</code> as follows:
      </p>
      <table>
       <thead>
         <tr>
           <th>value of <code>name</code></th>
           <th>culprit frame implicated in <code>attribution</code></th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><code>self</code></td>
           <td>empty</td>
         </tr>
         <tr>
           <td><code>same-origin-ancestor</code></td>
           <td>same-origin culprit frame</td>
         </tr>
         <tr>
           <td><code>same-origin-descendant</code></td>
           <td>same-origin culprit frame</td>
         </tr>
         <tr>
           <td><code>same-origin</code></td>
           <td>same-origin culprit frame</td>
         </tr>
         <tr>
           <td><code>cross-origin-ancestor</code></td>
           <td>empty</td>
         </tr>
         <tr>
           <td><code>cross-origin-descendant</code></td>
           <td>empty</td>
         </tr>
         <tr>
           <td><code>cross-origin-unreachable</code></td>
           <td>empty</td>
         </tr>
         <tr>
           <td><code>multiple-contexts</code></td>
           <td>empty</td>
         </tr>
         <tr>
           <td><code>unknown</code></td>
           <td>empty</td>
         </tr>
       </tbody>
     </table>
   </section>
 </section>

 <section id="sec-processing-model" data-link-for="PerformanceLongTaskTiming" data-link-for="TaskAttributionTiming">
  <h2>Processing Model</h2>
  <section id="sec-other-spec-modifications">
    <h3>Modifications to other specifications</h3>

    <h4>HTML: <a href="https://html.spec.whatwg.org/#definitions-3">event loop definitions</a></h4>
    <p>Each task gets an associated <i>start time</i>, <i>end time</i>, and a <i>script evaluation environment settings object set</i>.</p>

    <h4>HTML: <a href>event loop processing model</a></h4>
    Before Step #3:
    <ul><li>Set the selected task's start time to the value be the value that would be returned by the Performance object's now() method.</li></ul>

    After Step #3:
    <ul>
      <li>Set the selected task's end time to the value be the value that would be returned by the Performance object's now() method.</li>
      <li>Execute the report long tasks algorithm (below), passing in the selected task.</li>
    </ul>

    <h4>HTML: <a href="https://html.spec.whatwg.org/#calling-scripts">calling scripts</a></h4>
    <p>In prepare to run script, add a step at the end to add settings to the currently running task's script evaluation environment settings object set.</p>
  </section>

  <section id="sec-additions-to-spec">
    <h3>Additions to the Long Task Spec</h3>

    <h4>Report Long Tasks</h4>
    Given a task task, perform the following algorithm:
    <ol>
      <li>If end time minus start time is less than the long tasks threshold of 50 ms, abort these steps.</li>
      <li>Let destinationRealms be an empty set.</li>
      <li>Determine the set of JavaScript Realms to which reports will be delivered:<br>
        For each environment settings object settings in task's script evaluation environment settings object set:
        <ol>
          <li>Let topmostBC be settings's responsible browsing context's top-level browsing context.</li>
          <li>Add topmostBC's Window's relevant Realm to destinationRealms.</li>
          <li>Let descendantBCs be topmostBC's active document's list of descendant browsing contexts.</li>
          <li>For each descendantBC in descendantBCs, add descendantBC's Window's relevant Realm to destinationRealms.</li>
        </ol>
      </li>
      <li>For each destinationRealm in destinationRealms:
        <ol>
          <li>Let name be the empty string. This will be used to report minimal frame attribution, below.</li>
          <li>Let culpritSettings be null.</li>
          <li>Process task's script evaluation environment settings object set to determine name and culpritSettings as follows:
            <ol>
              <li>If task's script evaluation environment settings object set is empty: set name to “unknown” and culpritSettings to null.</li>
              <li>If task's script evaluation environment settings object set's length is greater than one: set name to "multiple-contexts” and culpritSettings to null.</li>
              <li>If task's script evaluation environment settings object set's length is one:
                <ol>
                  <li>Set culpritSettings to the single item in task's script evaluation environment settings object set.</li>
                  <li>Let destinationOrigin be destinationRealm's relevant settings object's origin.</li>
                  <li>Let destinationBC be destinationRealm's relevant settings object's responsible browsing context.</li>
                  <li>If culpritSettings's origin and destinationOrigin are [same origin]:
                    <ol>
                      <li>If culpritSettings's responsible browsing context is an ancestor of destinationBC, set name to “same-origin-ancestor”.</li>
                      <li>If culpritSettings's responsible browsing context is a descendant of destinationBC, set name to “same-origin-descendant”.</li>
                    </ol>
                  </li>
                  <li>Otherwise:
                    <ol>
                      <li>If culpritSettings's responsible browsing context is an ancestor of destinationBC, set name to “cross-origin-ancestor” and set culpritSettings to null.<br>NOTE: this is not reported because of security. Developers should look this up themselves.
                      </li>
                      <li>If culpritSettings's responsible browsing context is a descendant of destinationBC, set name to “cross-origin-descendant”.</li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Create a new <a>TaskAttributionTiming</a> object attribution and set its attributes as follows:
        <ol>
          <li>Set attribution's name attribute to "script".</li>
          <li>Set attribution's entryType attribute to “taskattribution”</li>
          <li>Set attribution's  startTime and duration to 0.</li>
          <li>If culpritSettings is not null, and culpritSettings's responsible browsing context has a browsing context container that is an iframe element, then let iframe be that element, and perform the following steps:
            <ol>
              <li>Set attribution's frameName attribute to the value of iframe's name content attribute, or null if the attribute is absent.</li>
              <li>Set attribution's frameSrc attribute to the value of iframe's src content attribute, or null if the attribute is absent.<br>NOTE: it is intentional that we record the frame's src attribute here, and not its current URL, as this is meant primarily to help identify frames, and allowing discovery of the current URL of a cross-origin iframe is a security problem.</li>
              <li>Set attribution's frameId attribute to the value of iframe's id content attribute, or null if the attribute is absent.</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Create a new <a>PerformanceLongTaskTiming</a> object newEntry and set its attributes as follows:
        <ol>
          <li>Set newEntry's name attribute to name.</li>
          <li>Set newEntry's entryType attribute to “longtask”</li>
          <li>Set newEntry's startTime attribute to start time</li>
          <li>Set newEntry's duration attribute to end time minus start time</li>
          <li>Set newEntry's attribution attribute to a new frozen array containing the single value attribution.<br>NOTE: future iterations of this API may add more values to the attribution attribute, but for now it only contains a single value.</li>
        </ol>
      </li>
      <li><a href="https://w3c.github.io/performance-timeline/#dfn-queue-a-performanceentry">Queue the PerformanceEntry</a> newEntry on destinationRealm.<br>NOTE: the "queue a PerformanceEntry" algorithm will end up doing nothing if no observers are registered. Implementations likely will want to bail out from this algorithm earlier in that case, instead of assembling all the above information only to find out nobody is listening for it.</li>
    </ol>
  </section>
</section>

<section id="sec-security">
  <h2>Security and Privacy Considerations</h2>
  <p>Long Tasks API adheres to cross-origin policy by including origin-safe attribution information about the source of the long task. 
    There is a 50ms threshold for long tasks, also timing info provided is clamped to 1ms resolution. Together this provides adequate protection against security attacks against browser.<br>
    However, privacy related attacks are possible, while the API doesn’t introduce any new privacy attacks, it could make existing privacy attacks faster. Mitigations for this are possible and discussed in the security review <a href="https://docs.google.com/document/d/1tIMI1gau_q6X5EBnjDNiFS5NWV9cpYJ5KKA7xPd3VB8/edit">in this document.</a>
  </p>
</section>


<section id="references" class="appendix" typeof="bibo:Chapter" resource="#references" property="bibo:hasPart">
  <h2 id="h-references" resource="#h-references"><span property="xhv:role" resource="xhv:heading"><span class="secno"></span>References</span>
  </h2>

  <section id="normative-references" typeof="bibo:Chapter" resource="#normative-references" property="bibo:hasPart">
    <h3 id="h-normative-references" resource="#h-normative-references">Normative references
    </h3>
    <dl class="bibliography" resource="">
      <dt id="biblio-html">[HTML]</dt>
      <dd>Ian Hickson. <a href="https://html.spec.whatwg.org/multipage/">HTML Standard</a>. Living Standard. URL: <a href="https://html.spec.whatwg.org/multipage/">https://html.spec.whatwg.org/multipage/</a>
      </dd>
      <dt id="bib-RFC6454">[RFC6454]</dt>
      <dd>A. Barth. IETF. <a href="https://tools.ietf.org/html/rfc6454" property="dc:requires"><cite>The Web Origin Concept</cite></a>. December 2011. Proposed Standard. URL: <a href="https://tools.ietf.org/html/rfc6454" property="dc:requires">https://tools.ietf.org/html/rfc6454</a></dd>
    </dl>
  </section>

  <section id="informative-references" typeof="bibo:Chapter" resource="#informative-references" property="bibo:hasPart">
    <h3 id="h-informative-references" resource="#h-informative-references"><span property="xhv:role" resource="xhv:heading">Informative references</span>
    </h3>
    <dl class="bibliography" resource="">
      <dt id="bib-PERFORMANCE-TIMELINE-2">[PERFORMANCE-TIMELINE-2]</dt>
      <dd>Ilya Grigorik; Jatinder Mann; Zhiheng Wang. W3C. <a href="https://www.w3.org/TR/performance-timeline-2/" property="dc:references"><cite>Performance Timeline Level 2</cite></a>. 8 December 2016. W3C Candidate Recommendation. URL: <a href="https://www.w3.org/TR/performance-timeline-2/" property="dc:references">https://www.w3.org/TR/performance-timeline-2/</a>
      </dd>
    </dl>
  </section>
</section>

</body>
</html>
